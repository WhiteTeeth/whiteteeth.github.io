<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文主要介绍 TCP 拥塞控制算法，内容多来自网上各个大佬的博客及《TCP&#x2F;IP详解》一书，在此基础上进行梳理总结，与大家分享。因水平有限，内容多有不足之处，请大佬轻喷。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP 拥塞控制详解">
<meta property="og:url" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Baiya&#39;s Blog">
<meta property="og:description" content="本文主要介绍 TCP 拥塞控制算法，内容多来自网上各个大佬的博客及《TCP&#x2F;IP详解》一书，在此基础上进行梳理总结，与大家分享。因水平有限，内容多有不足之处，请大佬轻喷。">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907045_39_w932_h704-20210207173827230.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907074_91_w1240_h963-20210207173827341.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907106_76_w1024_h577-20210207173827277.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907122_47_w613_h252-20210207173827327.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907140_91_w660_h210-20210207173827248.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907155_26_w699_h239-20210207173827192.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907179_56_w1240_h187-20210207173827319.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907191_90_w1240_h101-20210207173827338.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907204_22_w1240_h213-20210207173827348.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907216_96_w1240_h134-20210207173827345.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907232_33_w1240_h258-20210207173827476.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907251_62_w1240_h724-20210207173827525.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907268_29_w1240_h188-20210207173827447.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907281_57_w1240_h216-20210207173827467.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907295_83_w1240_h651-20210207173827530.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907328_49_w496_h248-20210207173827429.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907344_38_w658_h231-20210207173827507.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907363_16_w499_h251-20210207173827525.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907384_95_w720_h995-20210207173827621.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907402_80_w773_h606-20210207173827525.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907415_46_w1016_h526-20210207173827586.png">
<meta property="og:image" content="http://km.oa.com/files/photos/pictures/202004/1587907438_42_w720_h1247.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907453_36_w720_h623-20210207173827676.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907466_13_w720_h397-20210207173827620.png">
<meta property="og:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907479_22_w720_h399-20210207173827668.png">
<meta property="article:published_time" content="2020-04-26T13:13:53.000Z">
<meta property="article:modified_time" content="2021-12-09T06:23:08.689Z">
<meta property="article:author" content="Baiya">
<meta property="article:tag" content="网络">
<meta property="article:tag" content="TCP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907045_39_w932_h704-20210207173827230.png">

<link rel="canonical" href="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>TCP 拥塞控制详解 | Baiya's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?110151ea5147473925df3baed5fc3137";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Baiya's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baiya">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Baiya's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP 拥塞控制详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-26 21:13:53" itemprop="dateCreated datePublished" datetime="2020-04-26T21:13:53+08:00">2020-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-09 14:23:08" itemprop="dateModified" datetime="2021-12-09T14:23:08+08:00">2021-12-09</time>
              </span>

          
            <span id="/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="TCP 拥塞控制详解" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/26/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要介绍 TCP 拥塞控制算法，内容多来自网上各个大佬的博客及《TCP/IP详解》一书，在此基础上进行梳理总结，与大家分享。因水平有限，内容多有不足之处，请大佬轻喷。</p>
<span id="more"></span>

<h2 id="一、TCP-首部格式"><a href="#一、TCP-首部格式" class="headerlink" title="一、TCP 首部格式"></a>一、TCP 首部格式</h2><p>在了解 TCP 的拥塞控制之前，先来看看 TCP 的首部格式和一些基本概念。</p>
<p>TCP 头部标准长度是20字节。包含源端口、目的端口、序列号、确认号、数据偏移、保留位、控制位、窗口大小、校验和、紧急指针、选项等。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907045_39_w932_h704-20210207173827230.png" alt="TCP 首部格式"></p>
<h3 id="1-1-数据偏移（Data-Offset）"><a href="#1-1-数据偏移（Data-Offset）" class="headerlink" title="1.1 数据偏移（Data Offset）"></a>1.1 数据偏移（Data Offset）</h3><p>该字段长4位，单位为4字节。表示为 TCP 首部的长度。所以TCP 首部长度最多为60字节。</p>
<h3 id="1-2-控制位"><a href="#1-2-控制位" class="headerlink" title="1.2 控制位"></a>1.2 控制位</h3><p>目前的 TCP 控制位如下，其中 CWR 和 ECE 用于拥塞控制，ACK、RST、SYN、FIN 用于连接管理及数据传输。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CWR</span>：用于 IP 首部的 ECN 字段。ECE 为 <span class="number">1</span> 时，则通知对方已将拥塞窗口缩小。</span><br><span class="line"><span class="attribute">ECE</span>：在收到数据包的 IP 首部中 ECN 为 <span class="number">1</span> 时将 TCP 首部中的 ECE 设置为 <span class="number">1</span>，表示从对方到这边的网络有拥塞。</span><br><span class="line"><span class="attribute">URG</span>：紧急模式</span><br><span class="line"><span class="attribute">ACK</span>：确认</span><br><span class="line"><span class="attribute">PSH</span>：推送，接收方应尽快给应用程序传送这个数据。没用到</span><br><span class="line"><span class="attribute">RST</span>：该位为 <span class="number">1</span> 表示 TCP 连接中出现异常必须强制断开连接。</span><br><span class="line"><span class="attribute">SYN</span>：初始化一个连接的同步序列号</span><br><span class="line"><span class="attribute">FIN</span>：该位为 <span class="number">1</span> 表示今后不会有数据发送，希望断开连接。</span><br></pre></td></tr></table></figure>

<h3 id="1-3-窗口大小（Window）"><a href="#1-3-窗口大小（Window）" class="headerlink" title="1.3 窗口大小（Window）"></a>1.3 窗口大小（Window）</h3><p>该字段长度位16位，即 TCP 数据包长度位64KB。可以通过 <strong>Options</strong> 字段的 <strong>WSOPT</strong> 选项扩展到1GB。</p>
<h3 id="1-4-选项（Options）"><a href="#1-4-选项（Options）" class="headerlink" title="1.4 选项（Options）"></a>1.4 选项（Options）</h3><p>受 Data Offset 控制，长度最大为40字节。一般Option的格式为TLV结构：</p>
<table>
<thead>
<tr>
<th align="center">Kind / Type（1 Byte）</th>
<th align="center">Length（1 Byte）</th>
<th align="center">Value</th>
</tr>
</thead>
</table>
<p>常见的 TCP Options 有，SACK 字段就位于该选项中。：</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907074_91_w1240_h963-20210207173827341.png" alt="TCP Options"></p>
<h3 id="1-5-SACK-选项"><a href="#1-5-SACK-选项" class="headerlink" title="1.5 SACK 选项"></a>1.5 SACK 选项</h3><p>SACK 包括了两个 TCP 选项，一个选项用于标识是否支持 SACK，是在 TCP 连接建立时发送；另一种选项则包含了具体的 SACK 信息。</p>
<ol>
<li><p>SACK_Permitted选项，该选项只允许在TCP连接建立时，有SYN标志的包中设置，也即TCP握手的前两个包中，分别表示通信的两方各自是否支持SACK。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">TCP SACK-Permitted Option:</span><br><span class="line">Kind: 4</span><br><span class="line"><span class="section">Length: Variable</span></span><br><span class="line"><span class="section">+----------+----------+</span></span><br><span class="line"><span class="section">| Kind=4   | Length=2 |</span></span><br><span class="line"><span class="section">+----------+----------+</span></span><br></pre></td></tr></table></figure></li>
<li><p>SACK(选择性确认) 选项位于 Options 中。该选项参数告诉对方已经接收到并缓存的不连续的数据块，发送方可根据此信息检查究竟是哪些块丢失，从而发送相应的数据块。受TCP 包长度限制，TCP 包头最多包含四组 SACK 字段。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">TCP SACK Option:</span><br><span class="line">Kind: 5</span><br><span class="line">Length: Variable</span><br><span class="line"><span class="code">                  +--------+--------+</span></span><br><span class="line"><span class="section">                  | Kind=5 | Length |</span></span><br><span class="line"><span class="section">+--------+--------+--------+--------+</span></span><br><span class="line"><span class="section">|      Left Edge Of lst Block       |</span></span><br><span class="line"><span class="section">+--------+--------+--------+--------+</span></span><br><span class="line"><span class="section">|     Right Edge Of lst Block       |</span></span><br><span class="line"><span class="section">+--------+--------+--------+--------+</span></span><br><span class="line"><span class="section">|                   .  .  .         |</span></span><br><span class="line"><span class="section">+--------+--------+--------+--------+</span></span><br><span class="line"><span class="section">|      Left Edge Of nth Block       |</span></span><br><span class="line"><span class="section">+--------+--------+--------+--------+</span></span><br><span class="line"><span class="section">|     Right Edge Of nth Block       |</span></span><br><span class="line"><span class="section">+--------+--------+--------+--------+</span></span><br></pre></td></tr></table></figure></li>
<li><p>SACK 的工作原理<br>如下图所示， 接收方收到 500-699 的数据包，但没有收到 300-499 的数据包就会回 SACK(500-700) 给发送端，表示收到 500-699 的数据。</p>
</li>
</ol>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907106_76_w1024_h577-20210207173827277.png" alt="SACK 的工作原理"></p>
<h2 id="二、滑动窗口和包守恒原则"><a href="#二、滑动窗口和包守恒原则" class="headerlink" title="二、滑动窗口和包守恒原则"></a>二、滑动窗口和包守恒原则</h2><h3 id="2-1-滑动窗口"><a href="#2-1-滑动窗口" class="headerlink" title="2.1 滑动窗口"></a>2.1 滑动窗口</h3><p>为了解决可靠传输以及包乱序的问题，TCP 引入滑动窗口的概念。在传输过程中，client 和 server 协商接收窗口 rwnd，再结合拥塞控制窗口 cwnd 计算滑动窗口 swnd。在 Linux 内核实现中，滑动窗口 cwnd 是以包为单位，所以在计算 swnd 时需要乘上 mss （最大分段大小）。</p>
<p>$$swnd = min(rwnd, cwnd * mss)$$</p>
<p>如下图所示滑动窗口包含4部分：<br>#1 已收到ack确认的数据。<br>#2 已发还没收到ack的。<br>#3 在窗口中还没有发出的（接收方还有空间）。<br>#4 窗口以外的数据（接收方没空间）</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907122_47_w613_h252-20210207173827327.png" alt="TCP滑动窗口"></p>
<p>滑动后的示意图如下（收到36的ack，并发出了46-51的数据）：</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907140_91_w660_h210-20210207173827248.png" alt="TCP滑动后示意图"></p>
<h3 id="2-2-包守恒原则"><a href="#2-2-包守恒原则" class="headerlink" title="2.2 包守恒原则"></a>2.2 包守恒原则</h3><p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907155_26_w699_h239-20210207173827192.png" alt="包守恒原则"></p>
<p>TCP 维护一个发送窗口，估计当前网络链路上能容纳的数据包数量，希望在有数据可发的情况下，回来一个确认包就发出一个数据包，总是保持发送窗口那么多包在网络中流动。</p>
<p>传输的理想情况是要同时达到最大的吞吐量和最小的往返延迟，要达到这个目的，连接必须同时满足两个条件：</p>
<ol>
<li>以链路瓶颈带宽BtlBw发包 （带宽利用率最高）</li>
<li>保证链路中没有缓存队列（延迟最低）</li>
</ol>
<p>包守恒原则是拥塞控制的基础。</p>
<h2 id="三、TCP-重传机制"><a href="#三、TCP-重传机制" class="headerlink" title="三、TCP 重传机制"></a>三、TCP 重传机制</h2><p>本文重点介绍 TCP 拥塞控制相关，传输流程不在该范围之内，有兴趣的同学可以查阅相关文档。不过 TCP 重传逻辑和拥塞控制中的<code>快速重传</code>有关，所以在真正介绍拥塞控制算法之前，先来了解下 TCP 重传逻辑。</p>
<h3 id="3-1-超时重传-RFC2988"><a href="#3-1-超时重传-RFC2988" class="headerlink" title="3.1 超时重传 [RFC2988]"></a>3.1 超时重传 [RFC2988]</h3><p>RTT（Round Trip Time）由三部分组成：链路的传播时间（propagation delay）、末端系统的处理时间、路由器缓存中的排队和处理时间（queuing delay）。TCP 发送端得到了基于时间变化的 RTT 测量值，就能据此设置 RTO。<br>$$RTO = γ * RTO$$<br>当一个重传报文段被再次重传时，则增大 RTO 的退避因子 $γ$ 。通常情况下 $γ$ 值为1，多次重传 $γ$ 加倍增长为2，4，8等。通常 $γ$ 不能超过最大退避因子，Linux 下 RTO 不能超过 TCP_RTO_MAX（默认为 120s）。一旦收到相应的 ACK， $γ$ 重置为1。</p>
<p>下面介绍几种常用的 RTT 算法。</p>
<h4 id="3-1-1-rtt-经典算法-RFC793"><a href="#3-1-1-rtt-经典算法-RFC793" class="headerlink" title="3.1.1 rtt 经典算法 [RFC793]"></a>3.1.1 rtt 经典算法 [RFC793]</h4><p>1）首先，先采样RTT，记下最近几次的RTT值。<br>2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
<p>$$SRTT = ( α * SRTT ) + ((1- α) * RTT)$$</p>
<p>3）开始计算RTO。公式如下：</p>
<p>$$RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]$$</p>
<p>其中：</p>
<ul>
<li>  UBOUND 是最大的 timeout 时间，上限值</li>
<li>  LBOUND 是最小的 timeout 时间，下限值</li>
<li>  β 值一般在1.3到2.0之间。</li>
</ul>
<p>该算法的问题在于<strong>重传时，是用重传的时间还是第一次发数据的时间和ACK 回来的时间计算RTT样本值，另外，delay ack的存在也让 rtt 不能精确测量</strong>。</p>
<h4 id="3-1-2-rtt-标准算法（Jacobson-Karels-算法）"><a href="#3-1-2-rtt-标准算法（Jacobson-Karels-算法）" class="headerlink" title="3.1.2 rtt 标准算法（Jacobson / Karels 算法）"></a>3.1.2 rtt 标准算法（Jacobson / Karels 算法）</h4><p>该算法 [RFC6298] 特点是引入了最新的RTT的采样$rtt_s$和平滑过的$srtt$的差值做参数来计算。 公式如下：</p>
<ol>
<li><p>计算平滑RTT<br>$$srtt = srtt + α (rtt_s – srtt)$$</p>
</li>
<li><p>计算平滑RTT和真实的差距（加权移动平均）<br>$$rttvar = (1-β)<em>rttvar + β</em>(|rtt_s-srtt|)$$</p>
</li>
<li><p>计算RTO<br>$$rto= µ * srtt + ∂ *rttvar$$</p>
</li>
<li><p>考虑到时钟粒度，给RTO设置一个下界。<br>$$rto = max(µ * srtt + max(G, ∂ *rttvar), 1000)$$<br>这里$G$为计时器粒度，1000ms为整个RTO的下届值。（rfc6298 协议规范里采用保守的1000ms，不过协议也指出可以采用更小的rto值，linux源码中设为 TCP_RTO_MIN = HZ/5，即200ms）。在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） （Linux的源代码在：tcp_rtt_estimator）。</p>
</li>
<li><p>在首个 SYN 交换前，TCP 无法设置 RTO 初始值。根据 [RFC6298]，RTO 初始值为1s，而初始 SYN 报文段采用的超时间隔为3s。当计算出首个 RTT测量结果$rtt_s$，则按如下方法进行初始化：<br>$$srtt = rtt_s$$</p>
</li>
</ol>
<p>$$rttvar = rtt_s/2$$</p>
<h4 id="3-1-3-Karn-算法"><a href="#3-1-3-Karn-算法" class="headerlink" title="3.1.3 Karn 算法"></a>3.1.3 Karn 算法</h4><p>在RTT采样测量过程中，如果一个数据包初传后，RTO 超时重传，接着收到这个数据包的 ACK 报文，那么这个 ACK 报文是对应初传TCP报文还是对应重传TCP报文呢？这个问题就是重传二义性的问题。当没有使用 TSOPT 选项，单纯的 ACK 报文并不会指示对应初传包还是重传包，因此就会发生这个问题。<br>TCP Karn 算法是对经典算法在重传二义性问题上的一种改进。该算法分两部分。</p>
<ol>
<li>当出现超时重传，接收到重传数据的确认信息时不更新 RTT。即忽略了重传部分，避免重传二义性问题。</li>
<li>对该数据之后的包采取退避策略，仅当接收到未经重传的数据时，该 SRTT 才用于计算 RTO。</li>
</ol>
<p>因为单纯忽略重传数据时，如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），但因为重转的不算，RTO就不会被更新，这是个灾难。而且一发生重传就对现有的RTO值翻倍的方式也很难估算出准确的 RTT。</p>
<h4 id="3-1-4-TCP-时间戳选项（TSOPT）"><a href="#3-1-4-TCP-时间戳选项（TSOPT）" class="headerlink" title="3.1.4 TCP 时间戳选项（TSOPT）"></a>3.1.4 TCP 时间戳选项（TSOPT）</h4><p>根据 [RFC1323]，TSOPT 主要有两个用途，一个是 RTTM(round-trip time measurement)，即根据ACK报文中的这个选项测量往返时延；另外一个用途是 PAWS(protect against wrapped sequence numbers)，即防止同一个连接的系列号重叠。另外还有一些其他的用途，如SYN-cookie、 Eifel Detection Algorithm 等等。<br>TSOPT 为 Options 选项中一种，格式如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Kind: 8</span><br><span class="line"><span class="section">Length: 10 bytes</span></span><br><span class="line"><span class="section">+-------+-------+---------------------+---------------------+</span></span><br><span class="line"><span class="section">|Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|</span></span><br><span class="line"><span class="section">+-------+-------+---------------------+---------------------+</span></span><br><span class="line"><span class="code">    1       1              4                     4</span></span><br></pre></td></tr></table></figure>
<p><strong>RTT测量（RTTM）</strong><br>当使用这个选项的时候，发送方在 TSval 处放置一个时间戳，接收方则会把这个时间通过 TSecr 返回来。因为接收端并不会处理这个 TSval 而只是直接从 TSecr 返回来，因此不需要双方时钟同步。这个时间戳一般是一个单调增的值，[RFC1323] 建议这个时间戳每秒至少增加1。其中在初始 SYN 包中因为发送方没有对方时间戳的信息，因此 TSecr 会以0填充，TSval 则填充自己的时间戳信息。</p>
<p><strong>防回绕序列号（PAWS）</strong><br>TCP 判断数据是新是旧的方法是检查数据的序列号是否位于sun.una到sun.una + $2^{31}$的范围内，而序列号空间的总大小为$2^{32}$，即约4.29G。在万兆局域网中，4.29G字节数据回绕只需几秒钟，这时TCP就无法准确判断数据的新旧。<br>PAWS 假设接收到的每个 TCP 包中的 TSval 都是随时间单调增的，基本思想就是如果接收到的一个 TCP 包中的 TSval 小于刚刚在这个连接上接收到的报文的 TSval，则可以认为这个报文是一个旧的重复包而丢掉。时间戳回绕的速度只与对端主机时钟频率有关。Linux以本地时钟计数（jiffies）作为时间戳的值，假设时钟计数加1需要1ms，则需要约24.8天才能回绕一半，只要报文的生存时间小于这个值的话判断新旧数据就不会出错。</p>
<p><strong>SYN Cookie的选项信息</strong><br>TCP开启SYN Cookie功能时由于Server在收到SYN请求后不保存连接，故SYN包中携带的选项（WScale、SACK）无法保存，当SYN Cookie验证通过、新连接建立之后，这些选项都无法开启。<br>使用时间戳选项就可以解决上述问题。将WScale和SACK选项信息编码进32 bit的时间戳值中，建立连接时会收到ACK报文，将报文的时间戳选项的回显信息解码就可以还原WScale和SACK信息。</p>
<!--
[TCP系列08—连接管理—7、TCP 常见选项(option)](https://www.cnblogs.com/lshs/p/6038494.html)
[TCP/IP卷一:72---TCP超时与重传](https://blog.csdn.net/qq_41453285/article/details/104082993?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2)
[TCP timestamp](https://perthcharles.github.io/2015/08/27/timestamp-intro/)
[3.6 SYN Cookie](https://blog.csdn.net/u011130578/article/details/44465583)
-->
<h3 id="3-2-Fast-Retransmit（快速重传）"><a href="#3-2-Fast-Retransmit（快速重传）" class="headerlink" title="3.2 Fast Retransmit（快速重传）"></a>3.2 Fast Retransmit（快速重传）</h3><p>快速重传算法概括为：TCP 发送端在观测到至少 dupthresh（一般为3） 个重复 ACK 后，即重传可能丢失的数据分组，而不需等待重传计时器超时。</p>
<h4 id="3-2-1-SACK重传"><a href="#3-2-1-SACK重传" class="headerlink" title="3.2.1 SACK重传"></a>3.2.1 SACK重传</h4><ol>
<li>未启用 SACK 时，TCP 重复 ACK 定义为收到连续相同的 ACK seq。[RFC5681]</li>
<li>启用SACK 时，携带 SACK 的 ACK 也被认为重复ACK。[RFC6675] </li>
</ol>
<p>如下图所示（绿色为已发送并且被ack的数据包，黄色表示已发送还未确认的数据包，浅绿色为被Sack确认的数据包，蓝色表示还未发送的数据包），设 dupthresh = 3，SACKed_count = 6，从 unAcked 包开始的 SACKed_count - dupthresh 个数据包，即3个数据包会被标记为LOST。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907179_56_w1240_h187-20210207173827319.png" alt="拥塞窗口状态"></p>
<p>记分板状态如下，红色表示该数据包丢失：</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907191_90_w1240_h101-20210207173827338.png" alt="记分板状态"></p>
<h4 id="3-2-2-FACK-重传"><a href="#3-2-2-FACK-重传" class="headerlink" title="3.2.2 FACK 重传"></a>3.2.2 FACK 重传</h4><p>FACK 是 SACK 的一个激进版本，它拥有标准 SACK 算法的一切性质，除此之外，它<strong>假设网络不会使数据包乱序</strong>，因此收到最大的被 SACK 的数据包之前，FACK 均认为是丢失的。<br>FACK 模式下，重传时机为 <strong>被SACKed 的包数 + 空洞数 &gt; dupthresh</strong>。</p>
<p>如下图所示，设 dupthresh = 3，FACKed_count = 12，从unACKed 包开始的 FACKed_count - dupthresh 个数据包，即9个包会被标记为LOST。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907204_22_w1240_h213-20210207173827348.png" alt="拥塞窗口状态"></p>
<p>记分板状态如下，红色表示该数据包丢失：</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907216_96_w1240_h134-20210207173827345.png" alt="记分板状态"></p>
<h4 id="3-2-3-RACK-重传"><a href="#3-2-3-RACK-重传" class="headerlink" title="3.2.3 RACK 重传"></a>3.2.3 RACK 重传</h4><p><strong>基本思路</strong><br>如果数据包 p1 在 p2 之前发送，没有收到 p1 的确认，当收到 p2 的 Sack 时，推断 p1 丢包。<br><strong>算法简介</strong><br>每一个 skb 记录发送时间 xmit_time，传输控制块维护全局变量：rack.xmit_time，rack.reo_wnd。rack.xmit_time是接收方已经收到的最新的那个 skb 的发送时间，rack.reo_wnd是乱序的时间窗口大小。</p>
<ol>
<li><p>每次收到新的 ACK 后，更新 reo_wnd，其中 rtt_min 为固定时间窗口的 rtt 最小值。<br>$$reo_wnd = max(rtt_min / 4, 1ms)$$</p>
</li>
<li><p>每当收到一个 ACK 或者 SACK 的时候，更新 rack.xmit_time。再去遍历发送队列上已经发送但还没有收到确认的数据包（skb），如果满足如下条件，那么标记这个数据包丢了。<br>$$rack.xmit_time - skb.xmit_time &gt; reo_wnd$$</p>
</li>
<li><p>如果没有收到确认，那么就用定时器每个一段时间看看有哪些包丢了，如果满足如下条件，那么把这个skb标记为已经丢了：<br>$$currentTime &gt; skb.xmit_time + min_rtt + rack.reo_wnd + 1ms$$</p>
</li>
</ol>
<p>注：目前linux内核中只实现了第一种判断方法，定时器还没有实现，这样的话就还没有解决对于尾部包丢失的问题。</p>
<!--
[tcp中RACK算法](https://blog.csdn.net/noma_hwang/article/details/53906565)
[TCP系列23—重传—13、RACK重传](https://www.cnblogs.com/lshs/p/6038592.html)
-->

<h4 id="3-2-4-乱序检测"><a href="#3-2-4-乱序检测" class="headerlink" title="3.2.4  乱序检测"></a>3.2.4  乱序检测</h4><p>乱序检测的目的时探测网络是否发生重排导致的丢包，并以此来更新 dupthresh 值。<br>只要能收到一个 ACK 或者 SACK，其序列号位于当前已经被 ACK 或 SACK 的数据包最大的序列号之前，就说明网络发生了重排造成了乱序，此时如果涉及的数据包大小大于当前能容忍的网络乱序值，即 dupthresh 值，就说明网络乱序加重了，此时应该更新 dupthresh 值。<br>之所以保持 dupthresh 的值递增，是考虑其初始值3只是一个经验值，既然真实检测到乱序，如果其值比3小，并不能说明网络的乱序度估计偏大，同时TCP保守地递增乱序度，也是为了让快速重传的进入保持保守的姿态，从而增加友好性。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907232_33_w1240_h258-20210207173827476.png"></p>
<p>一旦发现 dupthresh 值更新的情形，FACK的假设便不成立，必须在连接内永久禁用FACK 算法。</p>
<h3 id="3-3-Early-Retransmit-for-TCP（ER-机制）"><a href="#3-3-Early-Retransmit-for-TCP（ER-机制）" class="headerlink" title="3.3 Early Retransmit for TCP（ER 机制）"></a>3.3 Early Retransmit for TCP（ER 机制）</h3><p><strong>要解决的问题:</strong><br>当无法收到足够的 dupack 时，TCP标准的 Fast Retransmit 机制无法被触发，只能等待 RTO 超时才能进行丢包的重传。而 RTO 超时不管是时间等待代价，还是性能损耗代价都很大。</p>
<p><strong>解决方法:</strong><br>检测出无法收到足够 dupack 的场景，进而降低 dupack threshold 来触发快速重传。从而避免等待 RTO 超时重传，对性能造成较大的损耗。</p>
<p>总结出现dupack不够的情况：<br>a. cwnd较小<br>b. 发送窗口里大量的数据包都被丢失了<br>c. 在数据发送的尾端发生丢包时</p>
<p>但是，上面各种极端的case有共同的特点：<br>m. 无法产生足够的dupack<br>n. 没有新的数据包可以发送进入网络</p>
<p>ER 机制就是在判断条件 m 和 n 都成立后，选择降低触发 Fast Retransmit 的阈值，来避免只能通过 RTO 超时重传的问题。</p>
<!--
[Early Retransmit for TCP](http://perthcharles.github.io/2015/10/31/wiki-network-tcp-early-retrans/)
-->

<h3 id="3-4-TCP-Tail-Loss-Probe（TLP-算法）"><a href="#3-4-TCP-Tail-Loss-Probe（TLP-算法）" class="headerlink" title="3.4 TCP Tail Loss Probe（TLP 算法）"></a>3.4 TCP Tail Loss Probe（TLP 算法）</h3><p>ER 算法解决了 dupack 较少时无法触发快速重传的问题，但当发生尾丢包时，由于尾包后没有更多数据包，也就无法触发 dupack。TLP 算法通过发送一个 loss probe 包，以产生足够的 SACK/FACK 数据包来触发重传。<br>TLP 算法会在 TCP 还是 Open 态时设置一个 Probe timeout（PTO），当链路中有未被确认的数据包，同时在 PTO 时间内未收到任何ACK，则会触发 PTO 超时处理机制。<br>TLP会选择传输序号最大的一个数据包作为 tail loss probe 包，这个序号最大的包可能是一个可以发送的新的数据包，也可能是一个重传包。TLP通过这样一个 tail loss probe 包，如果能够收到相应的 ACK，则会触发 FR 机制，而不是 RTO 机制。</p>
<!--
[TCP Tail Loss Probe](http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/)
-->

<h3 id="3-5-伪超时与重传"><a href="#3-5-伪超时与重传" class="headerlink" title="3.5 伪超时与重传"></a>3.5 伪超时与重传</h3><p>在很多情况下，即使没有出现数据丢失也可能引发重传。这种不必要的重传称为伪重传，其主要造成原因是伪超时，即过早判定超时，其他因素如包失序、包重复，或ACK丢失也可能导致该现象。在实际RTT显著增长，超过当前RTO时，可能出现伪超时。在下层协议性能变化较大的环境中（如无线环境），这种情况出现得比较多。<br>TCP 为处理伪超时问题提出了许多方法。这些方法通常包含检测算法与响应算法。检测算法用于判断某个超时或基于计时器的重传是否真实，一旦认定出现伪超时则执行响应算法，用于撤销或减轻该超时带来的影响。<br>检测算法包含 DSACK 、Eifel检测算法、迁移RTO恢复算法(F-RTO) 三种。</p>
<h4 id="3-5-1-DSACK-扩展"><a href="#3-5-1-DSACK-扩展" class="headerlink" title="3.5.1 DSACK 扩展"></a>3.5.1 DSACK 扩展</h4><p>DSACK的主要目的是判断何时的重传是不必要的，并了解网络中的其他事项。通过 DSACK 发送端至少可以推断是否发生了包失序、 ACK丢失、包重复或伪重传。<br>D-SACK使用了 SACK 的第一个段来做标志，<br>a. 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK。<br>b. 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK。<br>[RFC2883] 没有具体规定发送端对DSACK怎样处理。 [RFC3708] 给出了一种实验算法，利用DSACK来检测伪重传，响应算法可采用Eifel响应算法。</p>
<!-- 
TODO DSACK 处理伪重传
-->

<h4 id="3-5-2-Eifel检测算法-RFC3522"><a href="#3-5-2-Eifel检测算法-RFC3522" class="headerlink" title="3.5.2 Eifel检测算法 [RFC3522]"></a>3.5.2 Eifel检测算法 [RFC3522]</h4><p>实验性的Eifel检测算法利用了 TCP 的 TSOPT 来检测伪重传。在发生超时重传后，Eifel 算法等待接收下一个 ACK，若为针对第一次传输（即原始传输）的确认，则判定该重传是伪重传。</p>
<p>与 DSACK 的比较：<br>利用 Eifel 检测算法能比仅采用 DSACK <strong>更早检测到伪重传行为</strong>，因为它判断伪重传的 ACK 是在启动丢失恢复之前生成的。相反， DSACK 只有在重复报文段到达接收端后才能发送，并且在 DSACK 返回至发送端后才能有所响应。及早检测伪重传更为有利，它能使发送端有效避免“回退N”行为。</p>
<h4 id="3-5-3-迁移RTO恢复算法-F-RTO"><a href="#3-5-3-迁移RTO恢复算法-F-RTO" class="headerlink" title="3.5.3 迁移RTO恢复算法(F-RTO)"></a>3.5.3 迁移RTO恢复算法(F-RTO)</h4><p>前移RTO恢复（Forward-RTO Recovery，F-RTO）[RFC5682]是检测伪重传的标准算法。它不需要任何TCP选项，因此只要在发送端实现该方法后，即使针对不支持TSOPT的接收端也能有效地工作。该算法<strong>只检测由重传计时器超时引发的伪重传</strong>，对之前提到的其他原因引起的伪重传则无法判断。</p>
<p>F-RTO 的工作原理如下：</p>
<ol>
<li>F-RTO 会修改TCP的行为，在超时重传后收到第一个 ACK 时，TCP会发送新（非重传）数据，之后再响应后一个到达的 ACK。</li>
<li>如果其中有一个为重复 ACK，则认为此次重传没问题。</li>
<li>如果这两个都不是重复 ACK，则表示该重传是伪重传。</li>
<li>重复ACK是在接收端收到失序的报文段产生的。这种方法比较直观。如果新数据的传输得到了相应的ACK，就使得接收端窗口前移。如果新数据的发送导致了重复ACK，那么接收端至少有一个或更多的空缺。这两种情况下，接收新数据都不会影响整体数据的传输性能。</li>
</ol>
<!--
[TCP/IP卷一:76---TCP超时与重传](https://blog.csdn.net/qq_41453285/article/details/104106014)
-->

<h2 id="四、拥塞状态机"><a href="#四、拥塞状态机" class="headerlink" title="四、拥塞状态机"></a>四、拥塞状态机</h2><p>TCP 通过拥塞状态机来决定收到 ACK 时 cwnd 的行为（增长或者降低）。TCP 拥塞状态机有 <code>Open</code>,<code>Disorder</code>,<code>Recovery</code>,<code>Lost</code>和<code>CWR</code>五种状态。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907251_62_w1240_h724-20210207173827525.png" alt="TCP拥塞控制状态机"></p>
<h3 id="4-1-Open"><a href="#4-1-Open" class="headerlink" title="4.1 Open"></a>4.1 Open</h3><p>当网络中没有发生丢包，也就不需要重传，sender按照<code>慢启动</code>或者<code>拥塞避免算法</code>处理到来的ACK。</p>
<h3 id="4-2-Disorder"><a href="#4-2-Disorder" class="headerlink" title="4.2 Disorder"></a>4.2 Disorder</h3><p>当sender检测到 dupack 或者 SACK，将会转移到 Disorder 状态，当处在这个这个状态中时，cwnd 将维持不变。每收到一个 dupack 或 SACK，发送方将发送一个新包。</p>
<h3 id="4-3-CWR"><a href="#4-3-CWR" class="headerlink" title="4.3 CWR"></a>4.3 CWR</h3><p>当 sender 收到 ACK 包含显示拥塞通知（ECN），这个 ECN 由路由器写在IP头中，告诉 TCP sender 网络拥塞，sender 不会立马降低 cwnd，而是根据<code>快速恢复算法</code>进行降窗，直到减为之前的一半。当cwnd正在减小cwnd，网络中有没有重传包时，这个状态就叫CWR，CWR可以被Recovery或者Loss中断。</p>
<h3 id="4-4-Recovery"><a href="#4-4-Recovery" class="headerlink" title="4.4 Recovery"></a>4.4 Recovery</h3><p>当sender因为<code>快速重传机制</code>触发丢包时，sender会重传第一个未被ACK的包，并进入Recovery状态。在Recovery状态期间，cwnd的处理同CWR大致一样，要么重传标记了lost的包，要么根据保守原则发送新包。直到网络中所有的包都被ACK，才会退出Recovery进入Open状态，Recovery状态可以被loss状态打断。</p>
<ol>
<li>经典 Reno 模式（非SACK模式）下，$SND_UNA &gt; SND_HIGH$ 时退出Recovery 状态。</li>
</ol>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907268_29_w1240_h188-20210207173827447.png" alt="Reno 模式退出Recovery状态"></p>
<p>如上图，数据包A、B、C可能没有丢失只是被延迟接收，然而没有SACK机制下无法判断是A、B、C的重传触发的3次重复ACK还是新数据1、2、3丢失1（或者1、2或者1、2、3）导致的重复ACK，两种情况均会马上把拥塞状态机带入到Recovery状态，然而前一种是不必要的。如果在SND_UNA == SND_HIGH 即转为Open 态，那么当发生上述1、2、3的延迟到达后，紧接着的Recovery 状态会再次将拥塞窗口减半，最终降低到一个极低值。</p>
<ol start="2">
<li>SACK/FACK模式下，$SND_UNA &gt;= SND_HIGH$ 时退出Recovery 状态。<br>因为即使发生经典 Reno 模式下的A、B、C失序到达，由于存在 SACK 信息，状态机会将此三个重复 ACK 记为三个重复的DSACK，在 SACK 模式下，判断是否进入 Recovery 状态的条件是被 SACK 的数据包数量大于 dupthresh，而 DSACK 不被计入到 SACKed 数量中。FACK 模式下只影响进入 Recovery 状态的时机，其核心仍建立在 SACK 之上，所以不影响退出的时机。</li>
</ol>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907281_57_w1240_h216-20210207173827467.png" alt="SACK/FACK模式退出Recovery状态"></p>
<h3 id="4-5-Loss"><a href="#4-5-Loss" class="headerlink" title="4.5 Loss"></a>4.5 Loss</h3><p>当RTO后，TCP sender进入Loss状态，所有在网络中的包被标记为lost，cwnd重置为1，通过slow start重新增加cwnd。Loss与Recovery状态的不同点在于，cwnd会重置为1，但是Recovery状态不会，Recovery状态下拥塞控制通过<code>快速恢复</code>算法逐步降低cwnd至sshthresh。Loss状态不能被其它任何状态中断，只有当网络中所有的包被成功ACK后，才能重新进入Open状态。</p>
<!--
[TCP重点系列之拥塞状态机](https://allen-kevin.github.io/2017/04/19/TCP%E9%87%8D%E7%82%B9%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E6%9C%BA/)
-->
<h2 id="五、拥塞控制"><a href="#五、拥塞控制" class="headerlink" title="五、拥塞控制"></a>五、拥塞控制</h2><p>拥塞的发生是因为路由器缓存溢出，拥塞会导致丢包，但丢包不一定触发拥塞。<br>拥塞控制是快速传输的基础。一个拥塞控制算法一般包括<code>慢启动算法</code>、<code>拥塞避免算法</code>、<code>快速重传算法</code>、<code>快速恢复算法</code>四部分。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907295_83_w1240_h651-20210207173827530.png" alt="拥塞窗口示意图"></p>
<h3 id="5-1-慢启动算法"><a href="#5-1-慢启动算法" class="headerlink" title="5.1 慢启动算法"></a>5.1 慢启动算法</h3><p>不同拥塞算法慢启动的逻辑有所不同，经典的 NewReno 慢启动的算法如下：</p>
<ol>
<li>连接建好的开始先初始化 cwnd = 10，表明可以传10个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd 加1。这样每当过了一个 RTT，cwnd 翻倍，呈指数上升。</li>
<li>还有一个ssthresh（slow start threshold），是一个上限。当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。</li>
</ol>
<p>Linux 3.0后采用了 <a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf">Google的论文《An Argument for Increasing TCP’s Initial Congestion Window》</a> 的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux 采用了 [RFC3390] 的建议，cwnd 跟 MSS 的值来变，如果MSS &lt; 1095，则cwnd = 4；如果MSS &gt; 2190，则 cwnd = 2；其它情况下，则是3。</p>
<h3 id="5-2-拥塞避免算法"><a href="#5-2-拥塞避免算法" class="headerlink" title="5.2 拥塞避免算法"></a>5.2 拥塞避免算法</h3><p>当 cwnd 增长到 sshthresh 时，就会进入“拥塞避免算法”。拥塞避免算法下 cwnd 成线性增长，即每经过一个往返时间RTT就把发送方的拥塞窗口 cwnd 加1，而不是加倍。这样就可以避免拥塞窗口快速增长的问题。</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">每收到一个 ack 时 cwnd 的变化：</span></span><br><span class="line"><span class="attr">cwnd </span>=<span class="string"> cwnd + 1 / cwnd</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-快速重传算法"><a href="#5-3-快速重传算法" class="headerlink" title="5.3 快速重传算法"></a>5.3 快速重传算法</h3><p>快速重传算法主要用于丢包检测，以便能更快重传数据包，更早的调整拥塞状态机状态，从而达到持续升窗的目的。<br>具体重传策略见第三节 <code>重传机制</code>。</p>
<h3 id="5-4-快速恢复算法"><a href="#5-4-快速恢复算法" class="headerlink" title="5.4 快速恢复算法"></a>5.4 快速恢复算法</h3><p>当检测到丢包时，TCP 会触发快速重传并进入降窗状态。该状态下 cwnd 会通过快速恢复算法降至一个合理值。从历史发展来看，分为四个个阶段。</p>
<h4 id="5-4-1-BSD初始版本"><a href="#5-4-1-BSD初始版本" class="headerlink" title="5.4.1 BSD初始版本"></a>5.4.1 BSD初始版本</h4><ol>
<li>收到3次重复ACK，ssthresh 设为 cwnd/2，cwnd = cwnd / 2 + 3;</li>
<li>每收到一个重复ACK，窗口值加1;</li>
<li>收到非重复ACK，窗口设为ssthresh，退出</li>
</ol>
<p>优点：在快速恢复期间，可以尽可能多的发送数据<br>缺点：由于快速恢复未完成，尽可能多发送可能会加重拥塞。</p>
<!--
![](https://upload-images.jianshu.io/upload_images/6357961-0023bb87a12cb0c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
-->
<h4 id="5-4-2-RFC3517-版本"><a href="#5-4-2-RFC3517-版本" class="headerlink" title="5.4.2 [RFC3517] 版本"></a>5.4.2 [RFC3517] 版本</h4><ol>
<li>收到3次重复ACK，ssthresh 设为 cwnd/2，cwnd = cwnd / 2 + 3;</li>
<li><strong>每收到一个重复ACK，窗口值加1/cwnd</strong>;</li>
<li>收到非重复ACK，窗口设为ssthresh，退出</li>
</ol>
<p>优点：在快速恢复期间，可以尽少量的发送数据（有利于拥塞恢复），且在快速恢复时间段的最后阶段，突发有利于抢带宽。<br>缺点：快速恢复末期的突发不利于公平性。</p>
<h4 id="5-4-3-Linux-rate-halving算法"><a href="#5-4-3-Linux-rate-halving算法" class="headerlink" title="5.4.3 Linux rate halving算法"></a>5.4.3 Linux rate halving算法</h4><p>Linux 上并没有按照 [RFC3517] 标准实现，而是做了一些修改并运用到内核中。</p>
<ol>
<li>收到3次重复ACK，<strong>sshthresh设置为cwnd/2，窗口维持不变</strong>。</li>
<li>每收到两个ACK（不管是否重复），窗口值减1：cwnd = cwnd - 1。</li>
<li>新窗口值取cwnd = MIN(cwnd, in_flight+1)。</li>
<li>直到退出快速恢复状态，cwnd = MIN(cwnd, ssthresh)。<!--
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">cwnd_down()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dec</span> = <span class="type">dec</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">dec</span> = decr&amp;<span class="number">1</span>;</span><br><span class="line">    CWND = CWND - <span class="type">dec</span>;</span><br><span class="line">    CWND = min(CWND, in_flight+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>–&gt;<br>优点：在快速恢复期间，取消窗口陡降过程，可以更平滑的发送数据<br>缺点：降窗策略没有考虑PIPE的容量特征，考虑一下两点：<br>a. 如果快速恢复没有完成，窗口将持续下降下去<br>b. 如果一次性ACK/SACK了大量数据，in_flight 会陡然减少，窗口还是会陡降，这不符合算法预期。</p>
<h4 id="5-4-4-prr-算法-RFC6937"><a href="#5-4-4-prr-算法-RFC6937" class="headerlink" title="5.4.4 prr 算法 [RFC6937]"></a>5.4.4 prr 算法 [RFC6937]</h4><p>PRR 算法是最新 Linux 默认推荐的快速恢复算法。prr 算法是一种按比例降窗的算法，其最终效果是：</p>
<ol>
<li>在快速恢复过程中，拥塞窗口非常平滑地向ssthresh收敛；</li>
<li>在快速恢复结束后，拥塞窗口处在ssthresh附近</li>
</ol>
<p>PRR降窗算法实时监控以下的变量：<br>in_flight：它是窗口的一个度量，in_flight的值任何时候都不能大于拥塞窗口的大小。<br>prr_delivered：本次收到ACK进入降窗函数的时候，一共被ACK或者SACK的数据段数量。它度量了本次从网络中清空了哪些数据段，从而影响in_flight。<br>prr_out：进入快速恢复状态后已经被发送了多少数据包。在transmit例程和retransmit例程中递增。<br>to_be_out：当前还可以再发多少数据包。</p>
<p><strong>算法原理</strong><br>根据<strong>数据包守恒原则</strong>，能够发送的数据包总量是本次接收到的ACK中确认的数据包的总量，然而处在拥塞状态要执行的并不是这个守恒发送的过程，而是降窗的过程，因此需要在被ACK的数据包数量和可以发送的数据包数量之间打一个折扣，PRR希望达到的目标是：</p>
<p>$$ssthresh/old_cwnd == 发送数据的速率/数据被ACK的速率$$<br>进一步<br>$$ssthresh/old_cwnd == (发送数据的速率<em>T)/(数据被ACK的速率</em>T)$$<br>即：<br>$$ssthresh/old_cwnd == pkts_out/acks_rcv$$</p>
<p>以此来将目标窗口收敛于ssthresh。刚进入快速恢复的时候的时候，窗口尚未下降，在收敛结束之前，下面的不等式是成立的：</p>
<p>$$ssthresh/old_cwnd &gt;= pkts_out/acks_rcv$$<br>因此：<br>$$acks_rcv*(ssthresh/old_cwnd) &gt;= pkts_out$$<br>考虑到数据包的守恒，设<br>$$extra = acks_rcv*(ssthresh/old_cwnd)-pkts_out$$</p>
<p>这意味着在收敛结束前，我们可以多发送 extra 这么多的数据包。</p>
<p><strong>降窗流程</strong><br>根据上述原理可以得到 prr 算法降窗流程如下：</p>
<ol>
<li>收到多次（默认为3）重复ACK，根据回调函数更新 ssthresh (reno 算法为 cwnd/2)，窗口维持不变;</li>
<li>每收到ACK（不管是否重复），按上述算法计算Extra;</li>
<li>新窗口值取cwnd = in_flight + Extra;</li>
<li>直到退出快速恢复，cwnd = ssthresh;</li>
</ol>
<p>优点：在快速恢复期间，取消了窗口陡降过程，可以更平滑发送数据，且降窗速率与PIPE容量相关。<br>缺点：不利于在拥塞恢复到正常时突发流量的发送。</p>
<!--
##### 算法代码
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void tcp_cwnd_reduction(struct sock *sk, int newly_acked_sacked, int flag)</span><br><span class="line">&#123;</span><br><span class="line">  struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">  int sndcnt = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">int</span> delta = tp-&gt;</span>snd_ssthresh - tcp_packets_in_flight(tp);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">if</span> (newly_acked_sacked &lt;= 0 || WARN_ON_ONCE(!tp-&gt;</span>prior_cwnd))</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">tp</span>-&gt;</span>prr_delivered += newly_acked_sacked;</span><br><span class="line">  <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Main idea : sending_rate = CC_reduction_factor * data_rate_at_the_receiver，</span></span><br><span class="line"><span class="comment">         * 按照拥塞算法得到的减小因子，按比例的减小pipe，最终使pipe收敛于snd_ssthresh。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="title">u64</span> dividend = (u64)tp-&gt;</span><span class="function"><span class="title">snd_ssthresh</span> * tp-&gt;</span>prr_delivered +</span><br><span class="line">             <span class="function"><span class="title">tp</span>-&gt;</span>prior_cwnd - <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">sndcnt</span> = div_u64(dividend, tp-&gt;</span><span class="function"><span class="title">prior_cwnd</span>) - tp-&gt;</span>prr_out;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flag &amp; (FLAG_RETRANS_DATA_ACKED | FLAG_LOST_RETRANS)) ==</span><br><span class="line">       FLAG_RETRANS_DATA_ACKED) &#123;</span><br><span class="line">        <span class="comment">/* tp-&gt;prr_delivered - tp-&gt;prr_out首先用于撤销之前对pipe的减小，即首先让网络中的数据包恢复守恒。</span></span><br><span class="line"><span class="comment">         * 然后，tp-&gt;prr_delivered &lt; tp-&gt;prr_out，因为目前是慢启动，网络中数据包开始增加：</span></span><br><span class="line"><span class="comment">         * 对于每个ACK，sndcnt = newly_acked_sacked + 1，使pipe加1，即慢启动。</span></span><br><span class="line"><span class="comment">         * delta使pipe最终收敛于snd_ssthresh。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    sndcnt = min_t(int, delta,</span><br><span class="line">             <span class="function"><span class="title">max_t</span>(int, tp-&gt;</span><span class="function"><span class="title">prr_delivered</span> - tp-&gt;</span>prr_out,</span><br><span class="line">             newly_acked_sacked) + <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sndcnt = min(delta, newly_acked_sacked);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Force a fast retransmit upon entering fast recovery */</span></span><br><span class="line">  <span class="function"><span class="title">sndcnt</span> = max(sndcnt, (tp-&gt;</span>prr_out ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">  <span class="function"><span class="title">tp</span>-&gt;</span>snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<h3 id="5-5-记分板算法"><a href="#5-5-记分板算法" class="headerlink" title="5.5 记分板算法"></a>5.5 记分板算法</h3><p>记分板算法是为了统计网络中正在传输的包数量，即<code>tcp_packets_in_flight</code>。只有当 cwnd &gt; tcp_packets_in_flight 时，TCP 才允许发送重传包或者新数据包到网络中。</p>
<!--
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This determines how many packets are &quot;in the network&quot; to the best</span></span><br><span class="line"><span class="comment"> * of our knowledge.  In many cases it is conservative, but where</span></span><br><span class="line"><span class="comment"> * detailed information is available from the receiver (via SACK</span></span><br><span class="line"><span class="comment"> * blocks etc.) we can make more aggressive calculations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this for decisions involving congestion control, use just</span></span><br><span class="line"><span class="comment"> * tp-&gt;packets_out to determine if the send queue is empty or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Read this equation as:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	&quot;Packets sent once on transmission queue&quot; MINUS</span></span><br><span class="line"><span class="comment"> *	&quot;Packets left network, but not honestly ACKed yet&quot; PLUS</span></span><br><span class="line"><span class="comment"> *	&quot;Packets fast retransmitted&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_packets_in_flight</span><span class="params">(<span class="keyword">const</span> struct tcp_sock *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tp-&gt;packets_out - <span class="built_in">tcp_left_out</span>(tp) + tp-&gt;retrans_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_left_out</span><span class="params">(<span class="keyword">const</span> struct tcp_sock *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tp-&gt;sacked_out + tp-&gt;lost_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;<br><code>tcp_packets_in_flight</code>和<code>packets_out</code>, <code>sacked_out</code>, <code>retrans_out</code>, <code>lost_out</code>有关。其中<code>packets_out</code>表示发出去的包数量，<code>sacked_out</code>为<code>sack</code>的包数量，<code>retrans_out</code>为重传的包数量，<code>lost_out</code>为<code>loss</code>的包数量，这里的<code>loss</code>包含<code>rto</code>,<code>FR</code>和<code>RACK</code>等机制判断出来的丢失包。</p>
<p>$$ tcp_packets_in_flight = packets_out - sacked_out + lost_out + retrans_out$$</p>
<p>为了可以正确统计这些数据，内核给每个tcp 包(<code>tcp_skb_cb</code>)添加了<code>sacked</code>字段标记该数据包当前的状态。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">  <span class="variable">__u8</span>		sacked;		<span class="comment">/* State flags for SACK.	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_SACKED_ACKED	0x01	<span class="comment">/* SKB ACK&#x27;d by a SACK block	*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_SACKED_RETRANS	0x02	<span class="comment">/* SKB retransmitted		*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_LOST		0x04	<span class="comment">/* SKB is lost			*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_TAGBITS		0x07	<span class="comment">/* All tag bits			*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_REPAIRED		0x10	<span class="comment">/* SKB repaired (no skb_mstamp_ns)	*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_EVER_RETRANS	0x80	<span class="comment">/* Ever retransmitted frame	*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCB_RETRANS		(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS| \</span></span><br><span class="line"><span class="meta">				TCPCB_REPAIRED)</span></span><br></pre></td></tr></table></figure>

<p>需要在意的有<code>TCPCB_SACKED_ACKED</code>（被SACK块ACK’d）,<code>TCPCB_SACKED_RETRANS </code>(重传),<code>TCPCB_LOST </code>（丢包），其状态转换图如下：</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907328_49_w496_h248-20210207173827429.png" alt="sack 处理记分板"></p>
<p>记分板状态转换逻辑如下：</p>
<ol>
<li>首先判定丢包，打<code>L</code> tag，lost_out++，即 <code>L</code></li>
<li>如果需要重传，打<code>R</code>tag，retrans_out++，即 <code>L|R</code></li>
<li>如果再次丢包，取消<code>R</code>tag，retrans_out–，lost_out维持不变，go to step2，此时标记位为 <code>L</code></li>
<li>当SACKED时，取消<code>L|R</code>，retrans_out–，lost_out–，此时为 <code>S</code></li>
<li>当snd_una向右更新时，packet_out–</li>
</ol>
<h3 id="5-6-拥塞窗口校验"><a href="#5-6-拥塞窗口校验" class="headerlink" title="5.6 拥塞窗口校验"></a>5.6 拥塞窗口校验</h3><p>在 [RFC2861] 中，区分了TCP连接数据传输的三种状态：</p>
<p>network-limited：TCP的数据传输受限于拥塞窗口而不能发送更多的数据。<br>application-limited：TCP的数据传输速率受限于应用层的数据写入速率，并没有到达拥塞窗口上限。<br>idle：发送端没有额外的数据等待发送，当数据发送间隔超过一个RTO的时候就认为是ilde态。</p>
<p>cwnd 代表了对网络拥塞状态的一个评估，拥塞控制要根据 ACK 来更新 cwnd 的前提条件是，当前的数据发送速率真实的反映了 cwnd 的状况，也就是说当前传输状态是 network-limited。假如 tcp 隔了很长时间没有发送数据包，即进入 idle，那么当前真实的网络拥塞状态很可能就会与 cwnd 反映的网络状况有差距。另外在 application-limited 的场景下，受限数据的 ACK 报文还可能把 cwnd 增长到一个异常大的值，显然是不合理的。基于上面提到的两个问题，[RFC2861] 引入了拥塞窗口校验(CWV，Congestion Window Validation)算法。</p>
<p>算法如下：当需要发送新数据时，首先看距离上次发送操作是否超过一个 RTO，如果超过，则</p>
<ol>
<li>更新 sshthresh 值，设为 max(ssthresh, (3/4) * cwnd)。</li>
<li>每经过一个空闲 RTT 时间，cwnd 值减半，但不小于 1 SMSS。</li>
</ol>
<p>对于应用受限阶段（非空闲阶段），执行相似的操作：</p>
<ol>
<li>已使用的窗口大小记为 $W_{used}$。</li>
<li>更新 ssthresh 值，设为 max(ssthresh, (3/4) * cwnd)。</li>
<li>cwnd 设为 cwnd 和 $W_{used}$ 的平均值。</li>
</ol>
<p>上述操作均减小了 cwnd，但 ssthresh 维护了 cwnd 的先前值。避免空闲阶段可能发生的大数据量注入，可以减轻对有限的路由缓存的压力，从而减少丢包情况的产生。注意 CWV 减小了 cwnd 值，但没有减小 ssthresh，因此采用这种算法的通常结果是，在长时间发送暂停后，发送方会进入慢启动阶段。Linux TCP 实现了 CWV 算法并默认启用。</p>
<!--
### 5.7 撤销cwnd
TODO
-->

<h2 id="六、常见的拥塞算法"><a href="#六、常见的拥塞算法" class="headerlink" title="六、常见的拥塞算法"></a>六、常见的拥塞算法</h2><h3 id="6-1-New-Reno-算法"><a href="#6-1-New-Reno-算法" class="headerlink" title="6.1 New Reno 算法"></a>6.1 New Reno 算法</h3><p>New Reno算法包含第五节中介绍的慢启动算法、拥塞避免算法、快速重传算法和prr算法。在此就不赘述。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907344_38_w658_h231-20210207173827507.png" alt="Reno cwnd 图"></p>
<h3 id="6-2-CUBIC-算法"><a href="#6-2-CUBIC-算法" class="headerlink" title="6.2 CUBIC 算法"></a>6.2 CUBIC 算法</h3><p>CUBIC 算法和 Reno 算法区别主要在于慢启动和拥塞避免两个阶段。因为Reno算法进入拥塞避免后每经过一个RTT窗口才加 1，拥塞窗口增长太慢，导致在高速网络下不能充分利用网络带宽。所以为了解决这个问题，BIC 和 CUBIC算法逐步被提了出来。</p>
<p>(BIC 算法基于二分查找，实现复杂，不看了。)</p>
<p>cubic 算法源码见 <code>tcp_cubic</code> 文件。</p>
<h4 id="6-2-1-CUBIC-算法原理"><a href="#6-2-1-CUBIC-算法原理" class="headerlink" title="6.2.1 CUBIC 算法原理"></a>6.2.1 CUBIC 算法原理</h4><p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907363_16_w499_h251-20210207173827525.png" alt="cubic 窗口增长函数"></p>
<p>CUBIC 的窗口增长函数是一个三次函数，非常类似于 BIC-TCP 的窗口增长函数。CUBIC 的详细运行过程如下，当出现丢包事件时，CUBIC 同 BIC-TCP 一样，会记录这时的拥塞窗口大小作为$W_{max}$，接着通过因子 $β$ 执行拥塞窗口的乘法减小，这里 $β$ 是一个窗口降低常数，并进行正常的 TCP 快速恢复和重传。从快速恢复阶段进入拥塞避免后，使用三次函数的凹轮廓增加窗口。三次函数被设置在 $W_{max}$ 处达到稳定点，然后使用三次函数的凸轮廓开始探索新的最大窗口。</p>
<p>CUBIC 的窗口增长函数公式如下所示：</p>
<p>$$W(t) = C(t - K)^3 + W_{max}$$</p>
<p>其中，<em>W(t)</em> 代表在时刻 <em>t</em> 的窗口大小，C是一个 CUBIC 的常量参数，t 是从上次丢包后到现在的时间，以秒为单位。K 是上述函数在没有进一步丢包的情况下将 W 增加到 $W_{max}$ 经历的时间，其计算公式如下：</p>
<p>$$K = \sqrt[3]{ \frac {W_{max} * (1 - β) }  {C} }$$</p>
<p>其中 $β$ 也是常量。</p>
<!--
在拥塞避免阶段每收到一个 ACK，CUBIC 都会计算在下个 RTT 的窗口增长速率。CUBIC 使用 $W(t+RTT)$ 作为拥塞窗口的候选值，假设当前拥塞窗口大小为 cwnd，根据cwnd的值，CUBIC有三种运行模式。
1. 如果 cwnd 小于Reno-TCP在上次丢包事件之后t时刻到达的窗口大小，那么CUBIC处于Reno-TCP模式。
2. 如果cwnd小于 $W_{max}$，那么CUBIC在三次函数的凹轮廓区域。
3. 如果cwnd大于 $W_{max}$，那么CUBIC处于三次函数的凸轮廓区域。
-->
<h4 id="6-2-2-Wmax-的更新"><a href="#6-2-2-Wmax-的更新" class="headerlink" title="6.2.2 Wmax 的更新"></a>6.2.2 Wmax 的更新</h4><p>每次丢包后，CUBIC-TCP 会开启一个新的时段，并取$max(last_max_cwnd , cwnd)$作为当前 $W_{max}$ 饱和点，记录在 bic_origin_point 字段中，源码如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static inline void bictcp_update(struct bictcp *ca, u32 cwnd, u32 acked)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (ca-&gt;</span>epoch_start == <span class="number">0</span>) &#123;  <span class="comment">//丢包后，开启一个新的时段</span></span><br><span class="line">    <span class="function"><span class="title">ca</span>-&gt;</span>epoch_start = tcp_jiffies32;	<span class="comment">/* record beginning */</span></span><br><span class="line">    <span class="function"><span class="title">ca</span>-&gt;</span>ack_cnt = acked;			<span class="comment">/* start counting */</span></span><br><span class="line">    <span class="function"><span class="title">ca</span>-&gt;</span>tcp_cwnd = cwnd;			<span class="comment">/* syn with cubic */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取max(last_max_cwnd , cwnd)作为当前Wmax饱和点</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (ca-&gt;</span>last_max_cwnd &lt;= cwnd) &#123;</span><br><span class="line">      <span class="function"><span class="title">ca</span>-&gt;</span>bic_K = <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="title">ca</span>-&gt;</span>bic_origin_point = cwnd;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Compute new K based on</span></span><br><span class="line"><span class="comment">			 * (wmax-cwnd) * (srtt&gt;&gt;3 / HZ) / c * 2^(3*bictcp_HZ)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      <span class="function"><span class="title">ca</span>-&gt;</span>bic_K = cubic_root(cube_factor</span><br><span class="line">                 * (<span class="function"><span class="title">ca</span>-&gt;</span>last_max_cwnd - cwnd));</span><br><span class="line">      <span class="function"><span class="title">ca</span>-&gt;</span><span class="function"><span class="title">bic_origin_point</span> = ca-&gt;</span>last_max_cwnd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3-hystart-混合启动算法"><a href="#6-2-3-hystart-混合启动算法" class="headerlink" title="6.2.3 hystart 混合启动算法"></a>6.2.3 hystart 混合启动算法</h4><p>标准的慢启动在BDP网络环境下表现不好，不好的原因主要有两个：</p>
<ol>
<li>标准慢启动的拥塞窗口指数式的增长方式过于激进容易导致大量丢包，丢包恢复性能损耗太大。<br>在ssthreshold值设置的过高时，慢启动一段时间后，cwnd的指数增长会显得过快。有可能在上一个RTT，cwnd刚好等于BDP；下一个RTT，cwnd就等于2BDP了。这样就可能导致多出的一个BDP的数据包被丢弃。这类丢包属于突发丢包（burst packet losses）。</li>
<li>被优化过的慢启动机制，丢包时在数据包重传恢复的时候碰巧试图去减小服务器的负载，导致数据包恢复慢。</li>
</ol>
<p>总结这些原因都是因为慢启动过程过于盲目，不能及时的预测拥塞，导致了大量丢包，所以混合慢启动机制的主要作用是在慢启动阶段试图找到“合理 ”的退出慢启动进入拥塞避免状态点（safe exit point）。 </p>
<p>Hystart 算法通过 ACK train 信息判断一个 Safe Exit Point for Slow Start. 同时为了避免计算带宽，通过一个巧妙的转换(具体建议看论文)，只要判断时间差是否超过 Forward one-way delay($D_{min}$)来决定是否退出慢启动。</p>
<p>Hystart 算法通过以下两个条件来判断是否应该退出慢启动</p>
<ol>
<li>一个窗口内的数据包的总传输间隔是否超过$D_{min}$</li>
<li>数据包的RTT sample(默认8个样本)是否出现较大幅度的增长。<br>如果前面8个样本中的最小rtt大于全局最小rtt与阈值的和，那么表示网络出现了拥塞，应立马进入拥塞避免阶段</li>
</ol>
<!--
源码如下：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYSTART_ACK_TRAIN      0x1 <span class="comment">//进入拥塞避免的条件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYSTART_DELAY          0x2 <span class="comment">//进入拥塞避免的条件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYSTART_MIN_SAMPLES    8   <span class="comment">//表示至少取一个RTT的前8个ACK作为样本</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYSTART_DELAY_MIN      (4u&lt;&lt;3) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYSTART_DELAY_MAX      (16u&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HYSTART_DELAY_THRESH clamp(x, HYSTART_DELAY_MIN, HYSTART_DELAY_MAX)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void hystart_update(struct sock *sk, u32 delay)</span><br><span class="line">&#123;</span><br><span class="line">    struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">    struct bictcp *ca = inet_csk_ca(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果ca-&gt;found &amp; hystart_detect为真，表示应该进入拥塞避免</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!(ca-&gt;</span>found &amp; hystart_detect)) &#123;</span><br><span class="line">        u32 now = bictcp_clock(); <span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* first detection parameter - ack-train detection */</span></span><br><span class="line">        <span class="comment">/* 前后到来的两个ACK的间隔时间小于hystart_ack_delta才有效 */</span></span><br><span class="line">        <span class="function"><span class="title">if</span> ((s32)(now - ca-&gt;</span>last_ack) &lt;= hystart_ack_delta) &#123;</span><br><span class="line">            <span class="function"><span class="title">ca</span>-&gt;</span>last_ack = now;  <span class="comment">//更新上一个ACK到来的时间</span></span><br><span class="line">            <span class="comment">/* 每次慢启动时会重置round_start为0，结合前面的if条件，下面的</span></span><br><span class="line"><span class="comment">             * if成立的条件是：从慢启动开始到现在经过的时间如果大于</span></span><br><span class="line"><span class="comment">             * delay_min&gt;&gt;4，那么可以进入拥塞避免了。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="title">if</span> ((s32)(now - ca-&gt;</span><span class="function"><span class="title">round_start</span>) &gt; ca-&gt;</span>delay_min &gt;&gt; <span class="number">4</span>)</span><br><span class="line">                <span class="function"><span class="title">ca</span>-&gt;</span>found |= HYSTART_ACK_TRAIN;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* obtain the minimum delay of more than sampling packets */</span></span><br><span class="line">        <span class="comment">/* 如果样本计数小于HYSTART_MIN_SAMPLES(默认为8) */</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (ca-&gt;</span>sample_cnt &lt; HYSTART_MIN_SAMPLES) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (ca-&gt;</span><span class="function"><span class="title">curr_rtt</span> == 0 || ca-&gt;</span>curr_rtt &gt; delay)</span><br><span class="line">                <span class="function"><span class="title">ca</span>-&gt;</span>curr_rtt = delay;<span class="comment">/* 更新样本中的最小rtt */</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">ca</span>-&gt;</span>sample_cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果样本大于8了，那么就可以判断是否要进入拥塞避免了</span></span><br><span class="line">            <span class="comment">/* 如果前面8个样本中的最小rtt大于全局最小rtt与阈值的和，那么表示网络出</span></span><br><span class="line"><span class="comment">             * 现了拥塞，应立马进入拥塞避免阶段，HYSTART_DELAY_THRESH()的返</span></span><br><span class="line"><span class="comment">             * 回值在前面的变量介绍中有说明。*/</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (ca-&gt;</span><span class="function"><span class="title">curr_rtt</span> &gt; ca-&gt;</span>delay_min +</span><br><span class="line">                HYSTART_DELAY_THRESH(<span class="function"><span class="title">ca</span>-&gt;</span>delay_min&gt;&gt;<span class="number">4</span>))</span><br><span class="line">                <span class="function"><span class="title">ca</span>-&gt;</span>found |= HYSTART_DELAY;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * Either one of two conditions are met,</span></span><br><span class="line"><span class="comment">         * we exit from slow start immediately.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* 如果为真就进入拥塞避免 */</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (ca-&gt;</span>found &amp; hystart_detect)</span><br><span class="line">            <span class="function"><span class="title">tp</span>-&gt;</span><span class="function"><span class="title">snd_ssthresh</span> = tp-&gt;</span>snd_cwnd;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--
[tcp cubic代码分析](https://www.cnblogs.com/mylinuxer/p/5146142.html)
[浅谈tcp cubic拥塞算法以及优化建议](https://blog.csdn.net/lishanmin11/article/details/77417894)
[TCP拥塞控制之CUBIC](https://allen-kevin.github.io/2017/12/21/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BCUBIC/)
[Hybrid Slow Start for High-Bandwidth and
Long-Distance Networks](https://pdfs.semanticscholar.org/25e9/ef3f03315782c7f1cbcd31b587857adae7d1.pdf)
[Hybrid Slow Start混合慢启动算法](https://www.jianshu.com/p/f2edbaca4f2c)
-->

<h3 id="6-3-BBR算法"><a href="#6-3-BBR算法" class="headerlink" title="6.3 BBR算法"></a>6.3 BBR算法</h3><p>BBR 全称 bottleneck bandwidth and round-trip propagation time。基于包丢失检测的 Reno、NewReno 或者 cubic 为代表，其主要问题有 Buffer bloat 和长肥管道两种。和这些算法不同，bbr 算法会时间窗口内的最大带宽 max_bw 和最小RTT min_rtt，并以此计算发送速率和拥塞窗口。</p>
<h4 id="6-3-1-BBR-算法原理"><a href="#6-3-1-BBR-算法原理" class="headerlink" title="6.3.1 BBR 算法原理"></a>6.3.1 BBR 算法原理</h4><p>如下图所示，当没有足够的数据来填满管道时，RTprop决定了流的行为；当有足够的数据填满时，那就变成了BtlBw来决定。这两条约束交汇在点 <strong>inflight = BtlBw*RTprop，也就是管道的BDP（带宽与时延的乘积）</strong>。当管道被填满时，那些超过的部分（inflight-BDP）就会在瓶颈链路中制造了一个队列，从而导致了RTT的增大。当数据继续增加直到填满了缓存时，多余的报文就会被丢弃了。拥塞就是发生在BDP点的右边，而拥塞控制算法就是来控制流的平均工作点离BDP点有多远。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907384_95_w720_h995-20210207173827621.png" alt="发送速率和RTT vs inflight"><br>RTProp : round-trip propagation time<br>BtlBW : bottleneck bandwidth</p>
<p>基于丢包的拥塞控制算法工作在bandwidth-limited区域的右边界区域，尽管这种算法可以达到最大的传输速率，但是它是以高延迟和高丢包率作为代价的。在存储介质较为小的时候，缓存大小只比BDP大一点，此时这种算法的时延并不会很高。然而，当存储介质变得便宜之后，交换机的缓存大小已经是ISP链路BDP的很多很多倍了，这导致了bufferbloat，从而导致了RTT从毫秒级升到了秒级。</p>
<p>当一个连接满足以下两个条件时，它可以在达到最高的吞吐量的同时保持最低时延：</p>
<ol>
<li>速率平衡：瓶颈带宽的数据到达速率与BtlBw相等；</li>
<li>填满管道：所有的在外数据（inflight data）与BDP（带宽与时延的乘积）相等</li>
</ol>
<p>bbr 算法关于拥塞窗口的核心就是计算 BtlBW 和 RTprop，根据这两者值计算 BDP。BtlBw和RTprop可能是动态变化的，所以需要实时地对它们进行估计。</p>
<p><strong>计算 RTprop</strong></p>
<p>目前TCP为了检测丢包，必须实时地跟踪RTT的大小。在任意的时间t，</p>
<p>$$RTT_t = RTprop_t + η _t$$</p>
<p>其中$η_t$表示“噪音”。造成噪声的因素主要有：链路队列，接收方的时延ACK配置，ACK聚合等因素等待。RTprop是路径的物理特性，并且只有路径变化才会改变。由于一般来说路径变化的时间尺度远远大于RTprop，所以RTprop可以由以下公式进行估计：</p>
<p>$$\overline{RTprop} = RTprop + min(η _t) = min(RTT_t) ∀ t ∈ [T−W_R,T] $$</p>
<p>即，在一个时间窗口中对RTT取最小值。一般将该窗口大小设置为几十秒至几分钟。</p>
<p><strong>计算 BtlBW</strong></p>
<p>bottleneck bandwidth的估计不像RTT那样方便，没有一种TCP spec要求实现算法来跟踪估计bottleneck带宽，但是，可以通过跟踪发送速率来估计bottleneck带宽。当发送方收到一个ACK报文时，它可以计算出该报文的RTT，并且从发出报文到收到ack报文这段时间的data Inflight。这段时间内的平均发送速率就可以以此计算出来：$$delivery_rate = delta_delivered/ delta_t$$<br>这个计算出的速率必定小于bottleneck速率（因为delta delivered是确定的，但是delta t会较大）。因此，BtlBw可以根据以下公式进行估计。<br>$$\overline{BtlBw} = max(delivery_rate_t)∀t∈[T-W_B, T]$$<br>其中，时间窗口大小的值一般为6~10个RTT。</p>
<p>TCP必须记录每个报文的离开时间从而计算RTT。BBR必须额外记录已经发送的数据大小，使得在收到每一个ACK之后，计算RTT及发送速率的值，最后得到RTprop和BtlBw的估计值。</p>
<h4 id="6-3-2-pacing-rate-和-cwnd"><a href="#6-3-2-pacing-rate-和-cwnd" class="headerlink" title="6.3.2 pacing_rate 和 cwnd"></a>6.3.2 pacing_rate 和 cwnd</h4><p>bbr 算法输出 pacing_rate 和 cwnd 两个数据。pacing_rate 决定发包速率，cwnd 为窗口大小。每一次ACK 都会根据当前的模式计算 pacing_rate 和 cwnd。注意在计算 pacing_rate 和 cwnd 时有 pacing_gain 和 cwnd_gain 两个参数，</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">bottleneck_bandwidth</span> = windowed_max(delivered / elapsed, <span class="number">10</span> round trips)</span><br><span class="line"><span class="attr">min_rtt</span> = windowed_min(rtt, <span class="number">10</span> seconds)</span><br><span class="line"></span><br><span class="line"><span class="attr">pacing_rate</span> = pacing_gain * bottleneck_bandwidth</span><br><span class="line"><span class="attr">cwnd</span> = max(cwnd_gain * bottleneck_bandwidth * min_rtt, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907402_80_w773_h606-20210207173827525.png" alt="BBR 和 Pacing rate"></p>
<h4 id="6-3-3-BBR-状态机"><a href="#6-3-3-BBR-状态机" class="headerlink" title="6.3.3 BBR 状态机"></a>6.3.3 BBR 状态机</h4><p>BBR 算法也是基于状态机。状态机有<code>STARTUP</code>、<code>DRAIN</code>、<code>PROBE_BW</code>、<code>PROBE_RTT</code>四种状态。不同状态下 <strong>pacing_gain</strong> 和 <strong>cwnd_gain</strong> 的取值会有所不同。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907415_46_w1016_h526-20210207173827586.png" alt="bbr 状态机"></p>
<p><code>STARTUP</code>：初始状态，该状态下类似于传统拥塞控制的慢启动阶段。该状态下<code>pacing_gain</code>和<code>cwnd_gain</code>为 <strong>2/ln(2)+1</strong>。因为这是最小的能够达到 Reno 或者 CUBIC算法启动速度的值。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We use a high_gain value of 2/ln(2) because it&#x27;s the smallest pacing gain</span></span><br><span class="line"><span class="comment"> * that will allow a smoothly increasing pacing rate that will double each RTT</span></span><br><span class="line"><span class="comment"> * and send the same number of packets per RTT that an un-paced, slow-starting</span></span><br><span class="line"><span class="comment"> * Reno or CUBIC flow would:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> bbr_high_gain  = BBR_UNIT * <span class="number">2885</span> / <span class="number">1000</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>DRAIN</code>：该状态为排除状态。在<strong>STARTUP</strong>状态下三轮没有涨幅超过25%时会进入该状态。该状态下<strong>BtlBw</strong>会根据<strong>bbr_drain_gain</strong>逐渐降低，直到 inflight 降到 BDP 为止。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The pacing gain of 1/high_gain in BBR_DRAIN is calculated to typically drain</span></span><br><span class="line"><span class="comment"> * the queue created in BBR_STARTUP in a single round:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">static</span> <span class="keyword">const</span> <span class="keyword">int</span> bbr_drain_gain = BBR_UNIT * <span class="number">1000</span> / <span class="number">2885</span>;</span><br></pre></td></tr></table></figure>
<p><code>PROBE_BW</code>：该状态下会照常计算当前的bw，即瞬时带宽。然而在计算pacing rate 以及 cwnd 时，并不会像在STARTUP状态时那样用一个很大的增益系数去扩张pacing rate和cwnd，而是顺序的在[5/4，3/4，1，1，1，1，1，1]中选一个，感官上bw就在其停止增长的地方上下徘徊了。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The gain for deriving steady-state cwnd tolerates delayed/stretched ACKs: */</span></span><br><span class="line"><span class="keyword">static</span> const <span class="keyword">int</span> bbr_cwnd_gain  = BBR_UNIT * <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* The pacing_gain values for the PROBE_BW gain cycle, to discover/share bw: */</span></span><br><span class="line"><span class="keyword">static</span> const <span class="keyword">int</span> bbr_pacing_gain[] = &#123;</span><br><span class="line">  BBR_UNIT * <span class="number">5</span> <span class="regexp">/ 4,	/</span>* probe <span class="keyword">for</span> more available bw */</span><br><span class="line">  BBR_UNIT * <span class="number">3</span> <span class="regexp">/ 4,	/</span>* drain queue and<span class="regexp">/or yield bw to other flows */</span></span><br><span class="line">  BBR_UNIT, BBR_UNIT, BBR_UNIT,	<span class="comment">/* cruise at 1.0*bw to utilize pipe, */</span></span><br><span class="line">  BBR_UNIT, BBR_UNIT, BBR_UNIT	<span class="comment">/* without creating excess queue... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>PROBE_RTT</code>：当PROBE_BW检测到连续10s没有更新min rtt时就会进入该状态。该状态的目标是保持BBR的公平性并定期排空瓶颈队列，以收敛到真实的min_rtt。进入该模式时，BBR 会将 cwnd 的上限设置为4个数据包。在flight pkg &lt;= 4后开始进行rtt探测，探测时间为200ms，探测结束后BBR 便会记录min rtt，并离开PROBE_RTT进入相应的模式。代码见<code>bbr_update_min_rtt</code>函数。</p>
<p><strong>Q：为什么PROBE_BW阶段 bbr_cwnd_gain 为 2？</strong><br>保证极端情况下，按照pacing_rate 发送的数据包全部丢包时也有数据继续发送，不会产生空窗期。</p>
<p><strong>Q：为什么在探测最小RTT的时候最少要保持4个数据包</strong><br>4个包的窗口是合理的，infilght分别是：刚发出的包，已经到达接收端等待延迟应答的包，马上到达的应答了2个包的ACK。一共4个，只有1个在链路上，另外1个在对端主机里，另外2个在ACK里。路上只有1个包。</p>
<!--
![RTT（蓝线），inflight（绿线）和发送速率（红线）细节](https://upload-images.jianshu.io/upload_images/6357961-ad79ab94a144e5d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
-->
<!--

#### 6.3.4 BBR pacing发送控制
TODO: [https://zhuanlan.zhihu.com/p/24431669](https://zhuanlan.zhihu.com/p/24431669)
-->

<h4 id="6-3-5-BBR-算法表现"><a href="#6-3-5-BBR-算法表现" class="headerlink" title="6.3.5 BBR 算法表现"></a>6.3.5 BBR 算法表现</h4><p>BBR将它的大部分时间的在外发送数据都保持为一个BDP大小，并且发送速率保持在估计得BtlBw值，这将会最小化时延。但是这会把网络中的瓶颈链路移动到BBR发送方本身，所以BBR无法察觉BtlBw是否上升了。所以，BBR周期性的在一个RTprop时间内将pacing_gain设为一个大于1的值，这将会增加发送速率和在外报文。如果BtlBw没有改变，那么这意味着BBR在网络中制造了队列，增大了RTT，而deliveryRate仍然没有改变。（这个队列将会在下个RTprop周期被BBR使用小于1的pacing_gain来消除）。如果BtlBw增大了，那么deliveryRate增大了，并且BBR会立即更新BtlBw的估计值，从而增大了发送速率。通过这种机制，BBR可以以指数速度非常快地收敛到瓶颈链路。<br>如下图所示，在1条10Mbps，40ms的流在20s稳定运行之后将BtlBw提高了1倍（20Mbps），然后在第40s又将BtlBw恢复至20Mbps。</p>
<p><img src="http://km.oa.com/files/photos/pictures/202004/1587907438_42_w720_h1247.png" alt="bbr 带宽变化"></p>
<p>下图展示了1个10Mbps，40ms的BBR流在一开始的1秒内，发送方（绿线）和接收方（蓝线）的过程。红线表示的是同样条件下的CUBIC发送。垂直的灰线表示了BBR状态的转换。下方图片展示了两种连接的RTT在这段时间的变化。注意，只有收到了ACK（蓝线）之后才能确定出RTT，所以在时间上有点偏移。图中标注了BBR何时学习到RTT和如何反应。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907453_36_w720_h623-20210207173827676.png" alt="10Mbps、40ms链路上BBR流的第一秒"></p>
<p>下图展示了在上图中展示的BBR和CUBIC流在开始8秒的行为。CUBIC（红线）填满了缓存之后，周期性地在70%~100%的带宽范围内波动。然而BBR（绿线）在启动过程结束后，就非常稳定地运行，并且不会产生任何队列。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907466_13_w720_h397-20210207173827620.png" alt="在10Mbps、40ms链路上的BBR流和CUBIC流的前8秒对比"></p>
<p>下图展示了在一条100Mbps，100ms的链路上，BBR和CUBIC在60秒内的吞吐量与随机丢包率（从0.001%~50%）的关系。在丢包率只有0.1%的时候，CUBIC的吞吐量就已经下降了10倍，并且在丢包率为1%的时候就几乎炸了。而理论上的最大吞吐量是链路速率乘以（1-丢包率）。BBR在丢包率为5%以下时还能基本维持在最大吞吐量附近，在15%丢包率的时候虽然有所下降但还是不错。</p>
<p><img src="tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/1587907479_22_w720_h399-20210207173827668.png" alt="BBC和CUBIC的吞吐量与丢包率的关系"></p>
<!--
[TCP拥塞控制之：BBR](https://allen-kevin.github.io/2017/05/25/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BBBR/)
[BBR: Congestion-Based Congestion Control](https://queue.acm.org/detail.cfm?id=3022184)
[BBR论文中文翻译](https://blog.csdn.net/yue2388253/article/details/88925203)
[tcp_bbr: add BBR congestion control](https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=0f8782ea14974ce992618b55f0c041ef43ed0b78)
[使用TCP时序图解释BBR拥塞控制算法的几个细节](https://blog.csdn.net/dog250/article/details/72042516)
[TCP BBR算法中Pacing，cwnd，fq以及TSQ对RTT的影响](https://blog.csdn.net/dog250/article/details/72849890)
[Linux Kernel 4.9 中的 BBR 算法与之前的 TCP 拥塞控制相比有什么优势？](https://www.zhihu.com/question/53559433)
[BBR Congestion Control](https://tools.ietf.org/id/draft-cardwell-iccrg-bbr-congestion-control-00.html)
-->

<h3 id="6-4-Westwood算法"><a href="#6-4-Westwood算法" class="headerlink" title="6.4 Westwood算法"></a>6.4 Westwood算法</h3><p>TCP Westwood算法简称TCPW，和 bbr 算法类似是基于带宽估计的一种拥塞控制算法。TCPW 采用和 Reno 相同的慢启动算法、拥塞避免算法。区别在于当检测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。</p>
<h4 id="6-4-1-如何测量带宽-bw-est"><a href="#6-4-1-如何测量带宽-bw-est" class="headerlink" title="6.4.1 如何测量带宽 bw_est"></a>6.4.1 如何测量带宽 bw_est</h4><p>和 bbr 算法不同，tcpw 带宽计算相当粗糙。tcpw 每经过一个RTT 测量一次带宽。假设经过时间为 delta，该时间内发送完成的数据量为 bk，则采样值为 bk / delta。然后和 rtt 一样，带宽采样值会经过一个平滑处理算出最终的带宽值。</p>
<p>$$bw_ns_est(k) = (7/8) * bw_ns_est(k-1) + (1/8) * bk / delta;$$ $$bw_est(k) = (7/8) * bw_est(k-1) + (1/8) * bw_ns_est(k) ; $$</p>
<h4 id="6-4-2-如何确认单位时间的发送量bk"><a href="#6-4-2-如何确认单位时间的发送量bk" class="headerlink" title="6.4.2 如何确认单位时间的发送量bk"></a>6.4.2 如何确认单位时间的发送量bk</h4><p>tcpw 采用一种粗糙的估算方式。在收到回包后，会根据当前的snd_una 和之前的 snd_una 之间的差值来估算被 ACK 的字节数，即关于SACK的信息会被丢失。具体逻辑见<code>westwood_acked_count</code>函数。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static inline u32 westwood_acked_count(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  const struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">  struct westwood *w = inet_csk_ca(sk);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">cumul_ack</span> = tp-&gt;</span><span class="function"><span class="title">snd_una</span> - w-&gt;</span>snd_una;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If cumul_ack is 0 this is a dupack since it&#x27;s not moving</span></span><br><span class="line"><span class="comment">	 * tp-&gt;snd_una.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (!w-&gt;</span>cumul_ack) &#123;</span><br><span class="line">    <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">accounted</span> += tp-&gt;</span>mss_cache;</span><br><span class="line">    <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">cumul_ack</span> = tp-&gt;</span>mss_cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">if</span> (w-&gt;</span><span class="function"><span class="title">cumul_ack</span> &gt; tp-&gt;</span>mss_cache) &#123;</span><br><span class="line">    <span class="comment">/* Partial or delayed ack */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (w-&gt;</span><span class="function"><span class="title">accounted</span> &gt;= w-&gt;</span>cumul_ack) &#123;</span><br><span class="line">      <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">accounted</span> -= w-&gt;</span>cumul_ack;</span><br><span class="line">      <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">cumul_ack</span> = tp-&gt;</span>mss_cache;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">cumul_ack</span> -= w-&gt;</span>accounted;</span><br><span class="line">      <span class="function"><span class="title">w</span>-&gt;</span>accounted = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">w</span>-&gt;</span><span class="function"><span class="title">snd_una</span> = tp-&gt;</span>snd_una;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">return</span> w-&gt;</span>cumul_ack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-3-计算-ssthresh"><a href="#6-4-3-计算-ssthresh" class="headerlink" title="6.4.3 计算 ssthresh"></a>6.4.3 计算 ssthresh</h4><p>计算ssthresh 公式很简单：  $$ssthresh = bw_est * Rtt_{min}$$<br>源码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP Westwood</span></span><br><span class="line"><span class="comment"> * Here limit is evaluated as Bw estimation*RTTmin (for obtaining it</span></span><br><span class="line"><span class="comment"> * in packets we use mss_cache). Rttmin is guaranteed to be &gt;= 2</span></span><br><span class="line"><span class="comment"> * so avoids ever returning 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static u32 tcp<span class="constructor">_westwood_bw_rttmin(<span class="params">const</span> <span class="params">struct</span> <span class="params">sock</span> <span class="operator">*</span><span class="params">sk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  const <span class="keyword">struct</span> tcp_sock *tp = tcp<span class="constructor">_sk(<span class="params">sk</span>)</span>;</span><br><span class="line">  const <span class="keyword">struct</span> westwood *w = inet<span class="constructor">_csk_ca(<span class="params">sk</span>)</span>;</span><br><span class="line"></span><br><span class="line">  return max<span class="constructor">_t(<span class="params">u32</span>, (<span class="params">w</span>-&gt;<span class="params">bw_est</span> <span class="operator">*</span> <span class="params">w</span>-&gt;<span class="params">rtt_min</span>)</span><span class="operator"> / </span>tp-&gt;mss_cache, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--

#### 参考文档
[更加精确的TCP Westwood拥塞控制算法](https://blog.csdn.net/dog250/article/details/53725222)
[TCP拥塞控制算法内核实现剖析（九）](https://blog.csdn.net/zhangskd/article/details/7449476)
[TCP Westwood: End-to-End Congestion Control for Wired/Wireless Networks](https://www.researchgate.net/publication/220292546_TCP_Westwood_End-to-End_Congestion_Control_for_WiredWireless_Networks)

-->

<!--

### 6.5 CDG算法
TODO
CDG算法的核心，在于盯着RTT的变化，以便判断是否队列已经填满，由此来指导丢包发生后的行为。要点有二：
1.如果队列满了而丢包，那么乘性减窗；
2.如果队列非满而丢包，那么概率性乘性减窗；
事实上，如果不是为了保证公平性，如果队列非满而丢包，完全可以不减窗。现在的问题是“如何判断队列是否已经满了”。
-->

<h2 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h2><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lshs/p/6038494.html">TCP系列08—连接管理—7、TCP 常见选项(option)</a><br><a target="_blank" rel="noopener" href="https://perthcharles.github.io/2015/08/27/timestamp-intro/">TCP timestamp</a><br><a target="_blank" rel="noopener" href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-early-retrans/">Early Retransmit for TCP</a><br><a target="_blank" rel="noopener" href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/">TCP Tail Loss Probe(TLP)</a><br><a target="_blank" rel="noopener" href="https://allen-kevin.github.io/2017/04/19/TCP%E9%87%8D%E7%82%B9%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E6%9C%BA/">TCP重点系列之拥塞状态机</a><br><a target="_blank" rel="noopener" href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf">Congestion Control in Linux TCP</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/51287078">TCP拥塞控制图解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/51404615">TCP进入快速恢复时的窗口下降算法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/noma_hwang/article/details/53906565">tcp中RACK算法</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lshs/p/6038592.html">TCP系列23—重传—13、RACK重传</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lshs/p/6038562.html">TCP系列18—重传—8、FACK及SACK reneging下的重传</a><br><a target="_blank" rel="noopener" href="https://zboya.github.io/post/tcp_rto_research_and_golang_implement/">TCP RTO计算方法以及go实现验证</a><br><a target="_blank" rel="noopener" href="http://sgros.blogspot.com/2012/02/calculating-tcp-rto.html">Calculating TCP RTO</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
              <a href="/tags/TCP/" rel="tag"># TCP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/25/ios-NSURLSession-%E4%B9%8B-background-session/" rel="prev" title="iOS NSURLSession 之 background session">
      <i class="fa fa-chevron-left"></i> iOS NSURLSession 之 background session
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/31/tools-CocoaPods-%E5%AE%9E%E8%B7%B5/" rel="next" title="CocoaPods 实践">
      CocoaPods 实践 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments" id="gitalk-container"></div>
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81TCP-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-text">一、TCP 首部格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%EF%BC%88Data-Offset%EF%BC%89"><span class="nav-text">1.1 数据偏移（Data Offset）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%8E%A7%E5%88%B6%E4%BD%8D"><span class="nav-text">1.2 控制位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%EF%BC%88Window%EF%BC%89"><span class="nav-text">1.3 窗口大小（Window）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E9%80%89%E9%A1%B9%EF%BC%88Options%EF%BC%89"><span class="nav-text">1.4 选项（Options）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-SACK-%E9%80%89%E9%A1%B9"><span class="nav-text">1.5 SACK 选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8C%85%E5%AE%88%E6%81%92%E5%8E%9F%E5%88%99"><span class="nav-text">二、滑动窗口和包守恒原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">2.1 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8C%85%E5%AE%88%E6%81%92%E5%8E%9F%E5%88%99"><span class="nav-text">2.2 包守恒原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81TCP-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-text">三、TCP 重传机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0-RFC2988"><span class="nav-text">3.1 超时重传 [RFC2988]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-rtt-%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-RFC793"><span class="nav-text">3.1.1 rtt 经典算法 [RFC793]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-rtt-%E6%A0%87%E5%87%86%E7%AE%97%E6%B3%95%EF%BC%88Jacobson-Karels-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-text">3.1.2 rtt 标准算法（Jacobson &#x2F; Karels 算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-Karn-%E7%AE%97%E6%B3%95"><span class="nav-text">3.1.3 Karn 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-TCP-%E6%97%B6%E9%97%B4%E6%88%B3%E9%80%89%E9%A1%B9%EF%BC%88TSOPT%EF%BC%89"><span class="nav-text">3.1.4 TCP 时间戳选项（TSOPT）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Fast-Retransmit%EF%BC%88%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%EF%BC%89"><span class="nav-text">3.2 Fast Retransmit（快速重传）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-SACK%E9%87%8D%E4%BC%A0"><span class="nav-text">3.2.1 SACK重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-FACK-%E9%87%8D%E4%BC%A0"><span class="nav-text">3.2.2 FACK 重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-RACK-%E9%87%8D%E4%BC%A0"><span class="nav-text">3.2.3 RACK 重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E4%B9%B1%E5%BA%8F%E6%A3%80%E6%B5%8B"><span class="nav-text">3.2.4  乱序检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Early-Retransmit-for-TCP%EF%BC%88ER-%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-text">3.3 Early Retransmit for TCP（ER 机制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-TCP-Tail-Loss-Probe%EF%BC%88TLP-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-text">3.4 TCP Tail Loss Probe（TLP 算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E4%BC%AA%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0"><span class="nav-text">3.5 伪超时与重传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-DSACK-%E6%89%A9%E5%B1%95"><span class="nav-text">3.5.1 DSACK 扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-Eifel%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-RFC3522"><span class="nav-text">3.5.2 Eifel检测算法 [RFC3522]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-%E8%BF%81%E7%A7%BBRTO%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95-F-RTO"><span class="nav-text">3.5.3 迁移RTO恢复算法(F-RTO)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">四、拥塞状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Open"><span class="nav-text">4.1 Open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Disorder"><span class="nav-text">4.2 Disorder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-CWR"><span class="nav-text">4.3 CWR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Recovery"><span class="nav-text">4.4 Recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Loss"><span class="nav-text">4.5 Loss</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">五、拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%85%A2%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95"><span class="nav-text">5.1 慢启动算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">5.2 拥塞避免算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="nav-text">5.3 快速重传算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95"><span class="nav-text">5.4 快速恢复算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-BSD%E5%88%9D%E5%A7%8B%E7%89%88%E6%9C%AC"><span class="nav-text">5.4.1 BSD初始版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-RFC3517-%E7%89%88%E6%9C%AC"><span class="nav-text">5.4.2 [RFC3517] 版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-Linux-rate-halving%E7%AE%97%E6%B3%95"><span class="nav-text">5.4.3 Linux rate halving算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95"><span class="nav-text">六、常见的拥塞算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-New-Reno-%E7%AE%97%E6%B3%95"><span class="nav-text">6.1 New Reno 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-CUBIC-%E7%AE%97%E6%B3%95"><span class="nav-text">6.2 CUBIC 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-CUBIC-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-text">6.2.1 CUBIC 算法原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-Wmax-%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-text">6.2.2 Wmax 的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-hystart-%E6%B7%B7%E5%90%88%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95"><span class="nav-text">6.2.3 hystart 混合启动算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-BBR%E7%AE%97%E6%B3%95"><span class="nav-text">6.3 BBR算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-BBR-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-text">6.3.1 BBR 算法原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-pacing-rate-%E5%92%8C-cwnd"><span class="nav-text">6.3.2 pacing_rate 和 cwnd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-BBR-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">6.3.3 BBR 状态机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-5-BBR-%E7%AE%97%E6%B3%95%E8%A1%A8%E7%8E%B0"><span class="nav-text">6.3.5 BBR 算法表现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-Westwood%E7%AE%97%E6%B3%95"><span class="nav-text">6.4 Westwood算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E5%A6%82%E4%BD%95%E6%B5%8B%E9%87%8F%E5%B8%A6%E5%AE%BD-bw-est"><span class="nav-text">6.4.1 如何测量带宽 bw_est</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E5%8D%95%E4%BD%8D%E6%97%B6%E9%97%B4%E7%9A%84%E5%8F%91%E9%80%81%E9%87%8Fbk"><span class="nav-text">6.4.2 如何确认单位时间的发送量bk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-%E8%AE%A1%E7%AE%97-ssthresh"><span class="nav-text">6.4.3 计算 ssthresh</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-text">七、参考文档</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Baiya</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Baiya</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"Xi1tArJjgkvJ5hk6h7GEBOg9-gzGzoHsz","app_key":"nTz617bzWhN9TKo3rlYI2KHG","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'ce8c6d4734d54af7f015',
      clientSecret: 'd5e6b0c8de898898c5cd50e2850f3b719fc70728',
      repo        : 'whiteteeth.github.io',
      owner       : 'WhiteTeeth',
      admin       : ['WhiteTeeth'],
      id          : 'e00a0d17a7722474eec86e31a156fd8c',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Xi1tArJjgkvJ5hk6h7GEBOg9-gzGzoHsz',
      appKey     : 'nTz617bzWhN9TKo3rlYI2KHG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
